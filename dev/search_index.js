var documenterSearchIndex = {"docs":
[{"location":"#TensorTrains.jl","page":"TensorTrains.jl","title":"TensorTrains.jl","text":"","category":"section"},{"location":"#Types","page":"TensorTrains.jl","title":"Types","text":"","category":"section"},{"location":"","page":"TensorTrains.jl","title":"TensorTrains.jl","text":"AbstractTensorTrain\nTensorTrain","category":"page"},{"location":"#TensorTrains.AbstractTensorTrain","page":"TensorTrains.jl","title":"TensorTrains.AbstractTensorTrain","text":"AbstractTensorTrain\n\nAn abstract type representing a Tensor Train. Currently, there is only one concrete subtype TensorTrain.\n\n\n\n\n\n","category":"type"},{"location":"#TensorTrains.TensorTrain","page":"TensorTrains.jl","title":"TensorTrains.TensorTrain","text":"TensorTrain{F<:Number, N} <: AbstractTensorTrain\n\nA type for representing a Tensor Train\n\nF is the type of the matrix entries\nN is the number of indices of each tensor (2 virtual ones + N-2 physical ones)\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"TensorTrains.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"TensorTrains.jl","title":"TensorTrains.jl","text":"normalize_eachmatrix!\nuniform_tt\nrand_tt\nbond_dims\nevaluate\nmarginals\ntwovar_marginals\nnormalization\nnormalize!(::TensorTrain)\n+\n-\nsample!\nsample","category":"page"},{"location":"#TensorTrains.normalize_eachmatrix!","page":"TensorTrains.jl","title":"TensorTrains.normalize_eachmatrix!","text":"normalize_eachmatrix!(A::TensorTrain)\n\nDivide each matrix by its maximum (absolute) element and return the sum of the logs of the individual normalizations. This is used to keep the entries from exploding during computations\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.uniform_tt","page":"TensorTrains.jl","title":"TensorTrains.uniform_tt","text":"uniform_tt(bondsizes::AbstractVector{<:Integer}, q...)\nuniform_tt(d::Integer, L::Integer, q...)\n\nConstruct a Tensor Train full of 1's, by specifying either:\n\nbondsizes: the size of each bond\nd a fixed size for all bonds, L the length\n\nand\n\nq a Tuple/Vector specifying the number of values taken by each variable on a single site\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.rand_tt","page":"TensorTrains.jl","title":"TensorTrains.rand_tt","text":"rand_tt(bondsizes::AbstractVector{<:Integer}, q...)\nrand_tt(d::Integer, L::Integer, q...)\n\nConstruct a Tensor Train with entries random in [0,1], by specifying either:\n\nbondsizes: the size of each bond\nd a fixed size for all bonds, L the length\n\nand\n\nq a Tuple/Vector specifying the number of values taken by each variable on a single site\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.bond_dims","page":"TensorTrains.jl","title":"TensorTrains.bond_dims","text":"bond_dims(A::TensorTrain)\n\nReturn a vector with the dimensions of the virtual bonds\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.evaluate","page":"TensorTrains.jl","title":"TensorTrains.evaluate","text":"evaluate(A::TensorTrain, X...)\n\nEvaluate the Tensor Train A at input X\n\nExample:\n\n    L = 3\n    q = (2, 3)\n    A = rand_tt(4, L, q...)\n    X = [[rand(1:qi) for qi in q] for l in 1:L]\n    evaluate(A, X)\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.marginals","page":"TensorTrains.jl","title":"TensorTrains.marginals","text":"marginals(A::TensorTrain; l, r)\n\nCompute the marginal distributions p(x^l) at each site\n\nOptional arguments\n\nl = accumulate_L(A), r = accumulate_R(A) pre-computed partial nommalizations\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.twovar_marginals","page":"TensorTrains.jl","title":"TensorTrains.twovar_marginals","text":"marginals(A::TensorTrain; l, r, M, Δlmax)\n\nCompute the marginal distributions for each pair of sites p(x^l x^m)\n\nOptional arguments\n\nl = accumulate_L(A), r = accumulate_R(A), M = accumulate_M(A) pre-computed partial normalizations\nΔlmax=length(A): compute marginals only at distance Δlmax: l-mle Δlmax\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.normalization","page":"TensorTrains.jl","title":"TensorTrains.normalization","text":"normalization(A::TensorTrain; l, r)\n\nCompute the normalization Z=sum_x^1ldotsx^L A^1(x^1)cdots A^L(x^L)\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.normalize!-Tuple{TensorTrain}","page":"TensorTrains.jl","title":"LinearAlgebra.normalize!","text":"normalize!(A::TensorTrain)\n\nNormalize A to a probability distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+","page":"TensorTrains.jl","title":"Base.:+","text":"+(A::TensorTrain, B::TensorTrain)\n\nCompute the sum of two Tensor Trains. Matrix sizes are doubled\n\n\n\n\n\n","category":"function"},{"location":"#Base.:-","page":"TensorTrains.jl","title":"Base.:-","text":"-(A::TensorTrain, B::TensorTrain)\n\nCompute the difference of two Tensor Trains. Matrix sizes are doubled\n\n\n\n\n\n","category":"function"},{"location":"#StatsBase.sample!","page":"TensorTrains.jl","title":"StatsBase.sample!","text":"sample!([rng], x, A::TensorTrain; r)\n\nDraw an exact sample from A and store the result in x.\n\nOptionally specify a random number generator rng as the first argument   (defaults to Random.GLOBAL_RNG) and provide a pre-computed r = accumulate_R(A).\n\nThe output is x,p, the sampled sequence and its probability\n\n\n\n\n\n","category":"function"},{"location":"#StatsBase.sample","page":"TensorTrains.jl","title":"StatsBase.sample","text":"sample([rng], A::TensorTrain; r)\n\nDraw an exact sample from A.\n\nOptionally specify a random number generator rng as the first argument   (defaults to Random.GLOBAL_RNG) and provide a pre-computed r = accumulate_R(A).\n\nThe output is x,p, the sampled sequence and its probability\n\n\n\n\n\n","category":"function"}]
}
