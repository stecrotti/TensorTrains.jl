var documenterSearchIndex = {"docs":
[{"location":"#TensorTrains.jl","page":"TensorTrains.jl","title":"TensorTrains.jl","text":"","category":"section"},{"location":"#Types","page":"TensorTrains.jl","title":"Types","text":"","category":"section"},{"location":"","page":"TensorTrains.jl","title":"TensorTrains.jl","text":"AbstractTensorTrain\nTensorTrain","category":"page"},{"location":"#TensorTrains.AbstractTensorTrain","page":"TensorTrains.jl","title":"TensorTrains.AbstractTensorTrain","text":"AbstractTensorTrain\n\nAn abstract type representing a Tensor Train. Currently, there is only one concrete subtype TensorTrain.\n\n\n\n\n\n","category":"type"},{"location":"#TensorTrains.TensorTrain","page":"TensorTrains.jl","title":"TensorTrains.TensorTrain","text":"TensorTrain{F<:Number, N} <: AbstractTensorTrain\n\nA type for representing a Tensor Train\n\nF is the type of the matrix entries\nN is the number of indices of each tensor (2 virtual ones + N-2 physical ones)\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"TensorTrains.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"TensorTrains.jl","title":"TensorTrains.jl","text":"normalize_eachmatrix!\nuniform_tt\nrand_tt\nbond_dims\nevaluate\nmarginals\ntwovar_marginals\nnormalization\nnormalize!(::TensorTrain)\n+\n-\nsample!\nsample\northogonalize_right!\northogonalize_left!\ncompress!","category":"page"},{"location":"#TensorTrains.normalize_eachmatrix!","page":"TensorTrains.jl","title":"TensorTrains.normalize_eachmatrix!","text":"normalize_eachmatrix!(A::TensorTrain)\n\nDivide each matrix by its maximum (absolute) element and return the sum of the logs of the individual normalizations. This is used to keep the entries from exploding during computations\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.uniform_tt","page":"TensorTrains.jl","title":"TensorTrains.uniform_tt","text":"uniform_tt(bondsizes::AbstractVector{<:Integer}, q...)\nuniform_tt(d::Integer, L::Integer, q...)\n\nConstruct a Tensor Train full of 1's, by specifying either:\n\nbondsizes: the size of each bond\nd a fixed size for all bonds, L the length\n\nand\n\nq a Tuple/Vector specifying the number of values taken by each variable on a single site\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.rand_tt","page":"TensorTrains.jl","title":"TensorTrains.rand_tt","text":"rand_tt(bondsizes::AbstractVector{<:Integer}, q...)\nrand_tt(d::Integer, L::Integer, q...)\n\nConstruct a Tensor Train with entries random in [0,1], by specifying either:\n\nbondsizes: the size of each bond\nd a fixed size for all bonds, L the length\n\nand\n\nq a Tuple/Vector specifying the number of values taken by each variable on a single site\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.bond_dims","page":"TensorTrains.jl","title":"TensorTrains.bond_dims","text":"bond_dims(A::TensorTrain)\n\nReturn a vector with the dimensions of the virtual bonds\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.evaluate","page":"TensorTrains.jl","title":"TensorTrains.evaluate","text":"evaluate(A::TensorTrain, X...)\n\nEvaluate the Tensor Train A at input X\n\nExample:\n\n    L = 3\n    q = (2, 3)\n    A = rand_tt(4, L, q...)\n    X = [[rand(1:qi) for qi in q] for l in 1:L]\n    evaluate(A, X)\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.marginals","page":"TensorTrains.jl","title":"TensorTrains.marginals","text":"marginals(A::TensorTrain; l, r)\n\nCompute the marginal distributions p(x^l) at each site\n\nOptional arguments\n\nl = accumulate_L(A), r = accumulate_R(A) pre-computed partial nommalizations\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.twovar_marginals","page":"TensorTrains.jl","title":"TensorTrains.twovar_marginals","text":"marginals(A::TensorTrain; l, r, M, Δlmax)\n\nCompute the marginal distributions for each pair of sites p(x^l x^m)\n\nOptional arguments\n\nl = accumulate_L(A), r = accumulate_R(A), M = accumulate_M(A) pre-computed partial normalizations\nΔlmax=length(A): compute marginals only at distance Δlmax: l-mle Δlmax\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.normalization","page":"TensorTrains.jl","title":"TensorTrains.normalization","text":"normalization(A::TensorTrain; l, r)\n\nCompute the normalization Z=sum_x^1ldotsx^L A^1(x^1)cdots A^L(x^L)\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.normalize!-Tuple{TensorTrain}","page":"TensorTrains.jl","title":"LinearAlgebra.normalize!","text":"normalize!(A::TensorTrain)\n\nNormalize A to a probability distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+","page":"TensorTrains.jl","title":"Base.:+","text":"+(A::TensorTrain, B::TensorTrain)\n\nCompute the sum of two Tensor Trains. Matrix sizes are doubled\n\n\n\n\n\n","category":"function"},{"location":"#Base.:-","page":"TensorTrains.jl","title":"Base.:-","text":"-(A::TensorTrain, B::TensorTrain)\n\nCompute the difference of two Tensor Trains. Matrix sizes are doubled\n\n\n\n\n\n","category":"function"},{"location":"#StatsBase.sample!","page":"TensorTrains.jl","title":"StatsBase.sample!","text":"sample!([rng], x, A::TensorTrain; r)\n\nDraw an exact sample from A and store the result in x.\n\nOptionally specify a random number generator rng as the first argument   (defaults to Random.GLOBAL_RNG) and provide a pre-computed r = accumulate_R(A).\n\nThe output is x,p, the sampled sequence and its probability\n\n\n\n\n\n","category":"function"},{"location":"#StatsBase.sample","page":"TensorTrains.jl","title":"StatsBase.sample","text":"sample([rng], A::TensorTrain; r)\n\nDraw an exact sample from A.\n\nOptionally specify a random number generator rng as the first argument   (defaults to Random.GLOBAL_RNG) and provide a pre-computed r = accumulate_R(A).\n\nThe output is x,p, the sampled sequence and its probability\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.orthogonalize_right!","page":"TensorTrains.jl","title":"TensorTrains.orthogonalize_right!","text":"orthogonalize_right!(A::TensorTrain; svd_trunc::SVDTrunc)\n\nBring A to right-orthogonal form by means of SVD decompositions.\n\nOptionally perform truncations by passing a SVDTrunc.\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.orthogonalize_left!","page":"TensorTrains.jl","title":"TensorTrains.orthogonalize_left!","text":"orthogonalize_left!(A::TensorTrain; svd_trunc::SVDTrunc)\n\nBring A to left-orthogonal form by means of SVD decompositions.\n\nOptionally perform truncations by passing a SVDTrunc.\n\n\n\n\n\n","category":"function"},{"location":"#TensorTrains.compress!","page":"TensorTrains.jl","title":"TensorTrains.compress!","text":"compress!(A::TensorTrain; svd_trunc::SVDTrunc)\n\nCompress A by means of SVD decompositions + truncations\n\n\n\n\n\n","category":"function"},{"location":"#SVD-Truncators","page":"TensorTrains.jl","title":"SVD Truncators","text":"","category":"section"},{"location":"","page":"TensorTrains.jl","title":"TensorTrains.jl","text":"SVDTrunc\nTruncThresh\nTruncBond\nTruncBondMax\nTruncBondThresh","category":"page"},{"location":"#TensorTrains.SVDTrunc","page":"TensorTrains.jl","title":"TensorTrains.SVDTrunc","text":"abstract type SVDTrunc\n\nSVD truncator. Can be threshold-based or bond size-based\n\n\n\n\n\n","category":"type"},{"location":"#TensorTrains.TruncThresh","page":"TensorTrains.jl","title":"TensorTrains.TruncThresh","text":"TruncThresh{T} <: SVDTrunc\n\nA type used to perform SVD-based truncations based on a threshold ε. Given a vector lambda of m singular values, those below varepsilonsqrtsum_k=1^m lambda_k^2 are truncated to zero.\n\nFIELDS\n\nε: threshold.\n\nsvd_trunc = TruncThresh(1e-5)\nM = rand(5,6)\nM_trunc = svd_trunc(M)\n\n\n\n\n\n","category":"type"},{"location":"#TensorTrains.TruncBond","page":"TensorTrains.jl","title":"TensorTrains.TruncBond","text":"TruncBond{T} <: SVDTrunc\n\nA type used to perform SVD-based truncations based on bond size m'. Given a vector lambda of m singular values, only the m largest are kept, the others are truncated to zero.\n\nFIELDS\n\nmprime: number of singular values to retain\n\nsvd_trunc = TruncBond(3)\nM = rand(5,6)\nM_trunc = svd_trunc(M)\n\n\n\n\n\n","category":"type"},{"location":"#TensorTrains.TruncBondMax","page":"TensorTrains.jl","title":"TensorTrains.TruncBondMax","text":"TruncBondMax{T} <: SVDTrunc\n\nSimilar to TruncBond, but also stores the maximum error sqrtfracsum_k=m+1^mlambda_k^2sum_k=1^mlambda_k^2 made since the creation of the object\n\nFIELDS\n\nmprime: number of singular values to retain\nmaxerr: a 1-element vector storing the maximum error\n\n\n\n\n\n","category":"type"},{"location":"#TensorTrains.TruncBondThresh","page":"TensorTrains.jl","title":"TensorTrains.TruncBondThresh","text":"TruncBondThresh{T} <: SVDTrunc\n\nA mixture of TruncBond and TruncThresh, truncates to the most stringent criterion.\n\n\n\n\n\n","category":"type"}]
}
